ユーザ情報テーブル
=====================

ユーザ情報のデータベースを作り、それを元にログインを処理を行うというユースケースについて考えます。

Redis
---------

ユーザ情報を管理する上で、どうしても絶対に変化しない、要素を特定するためのキーが必要になる。リレーショナル・データベースにおける主キー。Redisでは、incr、hincrby(ハッシュで複数のプライマリーキーをまとめたい場合)などを使ってインデックスを作れる。

.. code-block:: js

   var redis = require('redis');
   var client = redis.createClient();
   client.incr('user-primary-key', function (err, userId) {
       client.hset('email', userId, 'user@example.com');
   });

登録の名前やメールアドレスなどを主キー代わりに使うのはNG。編集されうる値を使ってしまうと、名前の変更が発生したときにデータベース中のデータを修正しなければならなくなるから。

ログインする時に、メールアドレスとパスワードを使う場合、次の2つのハッシュを作る必要がある。

* email -> userId
* userId -> password

下記はログインそのものには不要かもしれないが、ユーザに関連する情報を一括表示する過程で必要になる可能性が高い。

* userId -> email

ユーザのそれ以外の属性を持たせたい場合には、いくつか方法があります。上記のパスワードのように、userIdをキーとするハッシュを属性の数だけ作る方法もひとつあります。

あるいは、それぞれの要素を個別に見ることがなく、かならず一度にまとめて取得したり更新するというのであれば、userIdをキーとして、JSONか何かでシリアライズして格納するハッシュを１つだけ作るという方法もあります。

MongoDB
--------------

MongoDBはクエリーを使うことで、DBの要素を探せるため、用途ごとにハッシュ(コレクション)を用意する必要はない。また、デフォルトで ``_id`` が作られるので、IDを用意する必要はない。
特殊なオブジェクトなので、HTTP経由で操作するAPIを提供する場合は一工夫必要かもしれない。

..code-block:: js

  {
     _id: id,
     passowrd: "hashedpassword",
     email: "mail@example.com"
  }

IDでの検索は高速に行える。emailでログインする場合はemailをキーにして情報を取得してくる。ユーザ数が100ぐらいであればちょっと遅いぐらいで問題ないが、万の単位になるのであれば、
emailにインデックスを貼ることでルックアップが早くなる。

1:Nリレーション
==========================

ユーザがグループに属すというユースケースで考えます。

Redis
----------------

グループには、グループ名という属性があったとします。グループに関しての属性を格納するハッシュを用意します。groupIdを創る場合には、ユーザ情報で説明したとおり、incrやhincrbyなどを使って、重複のないキーを生成して設定します。

* groupId -> groupName

一番簡単な方法は、グループごとにセットを作る方法です。

* groupMembers:groupId -> set([userId...])

グループIDが3だったら、groupMembers:3というキーのセットを作ります。SADDでメンバーを追加、SISMEMBERでメンバーかどうか確認、SMEMBERSでメンバーを一括で取得します。
これで親を知っている時に、子の情報を取得したり、子の情報を変更することができます。

子供から親の情報を取得する場合は、親のIDを管理するハッシュを作る必要があります。

* userId -> groupId

それ以外の方法としては、グループ情報をJSONで持たせ、配列で格納する方法です。プログラムから複雑な条件で追加したり削除するのは簡単になる反面、何をするにも毎回JSONをパースする必要があるためパフォーマンスは良くないでしょう。
追加も情報取得して、追加してから設定します。間で他のクライアントから変更が加わると、他の変更を消してしまったり、データの整合性が崩れるため変更がないか確認をする必要があります。Redis 2.4以下ではできないことはないですが、楽観的ロックなので、再度書き込むところまで責任を持って行う必要があります。

MongoDB
------------------

MongoDBも、2通りの方法があります。

DBを使って関連を表現するには、親と子の両方のIDを持つ関連オブジェクトを作る方法です。これ一つで子から親をたどることもできますし、親から子供をたどることもできます。インデックスを貼るケースが多いでしょう。

Redisと同じく配列に入れて管理する方法もあります。MongoDBは内部の配列の要素に対するクエリーも備えているため、インデックスを貼るぐらいで、親→子も子→親も検索できます。この方式の何点は、子供の数の変動が大きい場合、
MongoDB内のチャンクよりもサイズが大きくなって、他のチャンクへの移動ということが発生する可能性が高い点です。

M:Nリレーション
====================

Redis
------------------

グループごとのセットの他、ユーザからのセットも用意すれば、M:Nリレーションが表現できます。親、子の両方をJSONにして表現することもできますが、関連を追加したときのデータの整合性を保証しつつ更新するのが大変になります。

MongoDB
-------------------

関連オブジェクトを使えばそのままM:Nが表現できます。
